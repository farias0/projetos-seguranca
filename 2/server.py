#! /usr/bin/env python

import socket
import sys
import traceback
import threading
import select

from message import Message
from messagetype import MessageType
from aes import AES
from rsa import RSA

SOCKET_LIST = []
TO_BE_SENT = []
SENT_BY = {}

PORT = 5537

# >>

class KeySet:
    def __init__(self, pub = None, sym = None):
        self.pub = pub
        self.sym = sym

class Keys:

    asym = RSA.gen_keys()
    __CLIENTS_SETS = {} # a dict of {tuple, KeySet}
                        # The tuple is generated by the socket lib, and contains the IP (str) and port (int)

    @classmethod
    def getForIp(self, ip: tuple) -> KeySet:
        '''Get a client's KeySet if it exists, or create an empty one if it doesn't'''
        set = self.__CLIENTS_SETS.get(ip)
        if set == None:
            self.__CLIENTS_SETS[ip] = KeySet()
            set = self.__CLIENTS_SETS.get(ip)
        return set

    @classmethod
    def setForIp(self, ip: tuple, set: KeySet) -> KeySet:
        '''Adds or replaces a client's KeySet, and returns it back'''
        self.__CLIENTS_SETS[ip] = set
        return set

# <<

class Server(threading.Thread):

    def init(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        self.sock.bind(('', PORT))
        self.sock.listen(2)
        SOCKET_LIST.append(self.sock)
        print("Server started on port " + str(PORT))

    # >>

    def do_handshake(self, ip: tuple, serialized_pub_key: bytes) -> None:
        '''Saves a client's pub key, and sends back its own, along with a symmetric key (signed, encrypted and hashed)'''
        print('Handshaking with client ' + str(ip))

        client_pub_key = RSA.deserialize_pub_key(serialized_pub_key)

        pub_key_msg = Message(MessageType.PUB_KEY_EXCHANGE, Keys.asym.serialized_pub())
        self.add_msg_to_queue(ip, pub_key_msg)

        sym_key = AES.gen_key()
        Keys.setForIp(ip, KeySet(client_pub_key, sym_key))

        encrypted_sym_key = RSA.sign(RSA.encrypt(sym_key, client_pub_key), Keys.asym.pvt)
        # RSA has its own hash, but to simplify our code we'll just hash again
        sym_key_msg = Message(MessageType.SYM_KEY_EXCHANGE, encrypted_sym_key)
        self.add_msg_to_queue(ip, sym_key_msg)

        print('Handshake complete with client ' + str(ip))
        return

    # <<

    def add_msg_to_queue(self, origin: tuple, message: Message) -> None:
        msg_bytes = message.serialize()
        TO_BE_SENT.append(msg_bytes)
        SENT_BY[msg_bytes] = (str(origin))

    def run(self):
        while 1:
            read, write, err = select.select(SOCKET_LIST, [], [], 0)
            for sock in read:
                if sock == self.sock:
                    sockfd, addr = self.sock.accept()
                    print(str(addr))

                    SOCKET_LIST.append(sockfd)
                    print(SOCKET_LIST[len(SOCKET_LIST) - 1])

                else:
                    try:
                        s = sock.recv(1024)
                        if s == '':
                            print(str(sock.getpeername()))
                            continue
                        else:
                            origin = sock.getpeername()
                            chunk = s

                            # >>

                            msg = Message.deserialize(chunk)
                            print('> new message ' + str(msg.type))
                            match msg.type:
                                case MessageType.PUB_KEY_EXCHANGE:
                                    self.do_handshake(origin, msg.content)
                                    continue
                                case MessageType.NORMAL:
                                    msg.content = AES.decrypt(msg.content, Keys.getForIp(origin).sym)
                                    self.add_msg_to_queue(origin, msg)
                                    continue

                            # <<

                    except Exception as e:
                        print(e)
                        print(str(sock.getpeername()))


class handle_connections(threading.Thread):

    # >>

    def route_msg(self, destination: socket.socket, msg: Message) -> None:
        '''Sends a message to destination. If the message type=NORMAL, encrypts it with the desntination's sym key.'''

        print('< sending type ' + str(msg.type))

        if msg.type == MessageType.NORMAL:
            try:
                sym_key = Keys.getForIp(destination.getpeername()).sym
                msg.content = AES.encrypt(msg.content, sym_key)
            except:
                msg = Message(MessageType.ASK_FOR_PUB_KEY)

        destination.send(msg.serialize())

    # <<

    def run(self):
        while 1:
            read, write, err = select.select([], SOCKET_LIST, [], 0)
            for items in TO_BE_SENT:
                for s in write:
                    try:
                        msg = Message.deserialize(items)
                        if (msg.type == MessageType.NORMAL and str(s.getpeername()) == SENT_BY[items]):
                            continue
                        if (msg.type != MessageType.NORMAL and str(s.getpeername()) != SENT_BY[items]):
                            continue
                        self.route_msg(s, msg)

                    except:
                        traceback.print_exc(file=sys.stdout)
                TO_BE_SENT.remove(items)
                del (SENT_BY[items])


if __name__ == '__main__':
    srv = Server()
    srv.init()
    srv.start()
    print(SOCKET_LIST)
    handle = handle_connections()
    handle.start()